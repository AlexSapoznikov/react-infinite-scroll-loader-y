{"version":3,"sources":["../../src/infinite-scroll.tsx","../../src/utils/dom-element-helpers.ts","App.tsx","index.tsx"],"names":["forwardRef","children","props","dataLength","loadMore","hasMore","loader","threshold","parentRef","startPage","loadFirstSetOnInit","resetDependencies","disabled","dummyContentRef","createRef","useState","firstPage","setFirstPage","page","setPage","currentDataLength","setCurrentDataLength","pagesLoaded","setPagesLoaded","externalResetDependencies","Array","reset","resetTo","resetToStartPage","Number","useImperativeHandle","ref","useEffect","console","parentElement","handle","scrollPosition","Math","document","window","scrollHeight","loadOnInit","thresholdExceeded","isPageLoaded","isParentHidden","style","display","request","offset","limit","Promise","resolve","setTimeout","data","fill","map","_","i","slice","total","App","items","setItems","hasMoreItems","setHasMoreItems","loadMoreItems","a","nextItems","combinedItems","concat","length","ceil","item","ReactDOM","render","getElementById"],"mappings":"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","file":"static/js/main.dcde0cfd.chunk.js","sourcesContent":["/**\n * Infinite scroll component\n */\nimport React, { forwardRef, RefObject, useEffect, useImperativeHandle, useState, Fragment, createRef } from 'react';\nimport { getBodyScrollHeight, getBodyScrollPosition } from './utils/dom-element-helpers';\n\ntype Props = {\n  loadMore: (page: number) => void,\n  dataLength: number,\n  children: React.ReactNode,\n  hasMore: boolean,\n  loader?: React.ReactNode,\n  threshold?: number,\n  parentRef?: RefObject<any>,\n  startPage?: number,\n  loadFirstSetOnInit?: boolean,\n  resetDependencies?: any | Array<any>, // Reset happens when these dependencies change\n  disabled?: boolean,\n}\n\ntype ResetToType = {\n  startPage?: number\n};\n\nexport type InfiniteScrollRefType = {\n  reset: (resetTo?: ResetToType) => void,\n};\n\nconst InfiniteScroll = forwardRef((props: Props, ref: RefObject<any>) => {\n  const {\n    children,\n    dataLength,\n    loadMore,\n    hasMore,\n    loader,\n    threshold,\n    parentRef,\n    startPage,\n    loadFirstSetOnInit,\n    resetDependencies,\n    disabled\n  } = props;\n  const defaultThreshold = 250;\n\n  const dummyContentRef = createRef<HTMLDivElement>();\n\n  // Initial state\n  const [firstPage, setFirstPage] = useState(startPage && startPage >= 0 ? startPage : 0); // Keep in state, so it won't change from props\n  const [page, setPage] = useState(firstPage);\n  const [currentDataLength, setCurrentDataLength] = useState(dataLength);\n  const [pagesLoaded, setPagesLoaded] = useState<number[]>([]);\n\n  // Dependencies to array of dependencies\n  const externalResetDependencies = (Array.isArray(resetDependencies) ? resetDependencies : [resetDependencies]);\n\n  // Reset\n  const reset = (resetTo: ResetToType = {}) => {\n    const { startPage: resetToStartPage }: any = resetTo;\n\n    if (Number.isInteger(resetToStartPage) && resetToStartPage >= 0) {\n      // Reset to passed first page\n      setFirstPage(resetToStartPage);\n      setPage(resetToStartPage);\n    } else {\n      // If start page not passed, reset to firstPage that component was initialized with\n      setPage(firstPage);\n    }\n\n    setCurrentDataLength(dataLength);\n    setPagesLoaded([]);\n  };\n\n  // Expose data to ref\n  useImperativeHandle(ref, (): InfiniteScrollRefType => ({\n    reset,\n  }));\n\n  // Reset all to initial state when reset dependencies change\n  useEffect(() => {\n    reset();\n  }, externalResetDependencies);\n\n  // Trigger page change\n  useEffect(() => {\n    if (!Number.isInteger(currentDataLength)) {\n      console.error('InfiniteScroll: dataLength prop is not a number', currentDataLength);\n    }\n\n    if (dataLength > currentDataLength) {\n      setPage(page + 1);\n    }\n\n    setCurrentDataLength(dataLength);\n  }, [dataLength]);\n\n  // Load next set of data\n  useEffect(() => {\n    if (disabled) {\n      return;\n    }\n\n    const parentElement = parentRef?.current;\n\n    const handle = () => {\n      const scrollPosition = parentElement\n        ? parentElement.scrollTop + parentElement.offsetHeight\n        : getBodyScrollPosition() + window.innerHeight;\n      const scrollHeight = parentElement\n        ? parentElement.scrollHeight\n        : getBodyScrollHeight();\n      const loadOnInit = loadFirstSetOnInit && page === firstPage;\n      const thresholdExceeded = scrollHeight - scrollPosition < (threshold || defaultThreshold);\n      const isPageLoaded = pagesLoaded.includes(page);\n      const isParentHidden = dummyContentRef?.current?.parentElement?.offsetHeight === 0;\n\n      // If there is more items to load and scroll position exceeds threshold, then load more items\n      if ((loadOnInit || (hasMore && thresholdExceeded)) && !isPageLoaded && !isParentHidden) {\n        setPagesLoaded([...pagesLoaded, page]);\n        loadMore(page);\n      }\n    };\n\n    // Initial run\n    handle();\n\n    // Add event listener after load\n    (parentElement || window).addEventListener('scroll', handle);\n    (parentElement || window).addEventListener('resize', handle);\n\n    // Cleanup\n    return () => {\n      (parentElement || window).removeEventListener('scroll', handle);\n      (parentElement || window).removeEventListener('resize', handle);\n    };\n  }, [\n    page,\n    pagesLoaded,\n    hasMore,\n    disabled\n  ]);\n\n  return (\n    <Fragment>\n      {/* dummy inside child for getting parent dom element */}\n      <div ref={dummyContentRef}\n           style={{ display: 'none' }}\n      />\n\n      {/* items */}\n      { children }\n\n      {/* loader */}\n      { hasMore && loader }\n    </Fragment>\n  );\n});\n\nexport default InfiniteScroll;\n","/**\n * Crossbrowser way to get body scroll position\n */\nexport function getBodyScrollPosition () {\n  return Math.max(\n    document.documentElement && document.documentElement.scrollTop,\n    document.body && document.body.scrollTop,\n    // @ts-ignore\n    document.scrollingElement && document.scrollingElement.scrollTop\n  );\n}\n\n/**\n * Crossbrowser way to get body scroll height\n */\nexport function getBodyScrollHeight () {\n  return Math.max(\n    document.documentElement && document.documentElement.scrollHeight,\n    document.body && document.body.scrollHeight,\n    // @ts-ignore\n    document.scrollingElement && document.scrollingElement.scrollHeight\n  );\n}\n","import React, { useState } from 'react'\n\nimport InfiniteScroll from 'react-infinite-scroll-loader-y'\n\nfunction request ({ offset, limit }: { offset: number, limit: number }): Promise<{ data: string[], total: number }> {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve({\n        data: Array(500).fill(null).map((_, i) => `item-${i + 1}`).slice(offset, offset + limit),\n        total: 500,\n      });\n    }, 500)\n  });\n}\n\nconst App = () => {\n  const [items, setItems] = useState<string[]>([]);\n  const [hasMoreItems, setHasMoreItems] = useState(true);\n\n  const ITEMS_PER_PAGE = 20;\n\n  const loadMoreItems = async (page: number) => {\n    const { data: nextItems, total } = await request({\n      offset: ITEMS_PER_PAGE * page,\n      limit: ITEMS_PER_PAGE,\n    });\n\n    // Combine items\n    const combinedItems = items.concat(nextItems || []);\n\n    // Check for more\n    setHasMoreItems(!!nextItems?.length && total > combinedItems.length);\n\n    // Save items to state\n    setItems(combinedItems);\n  };\n\n  return (\n    <InfiniteScroll dataLength={items.length}\n                    loadMore={page => loadMoreItems(page)}\n                    hasMore={hasMoreItems}\n                    loader={<div>Loading...</div>}\n                    loadFirstSetOnInit={!items.length}\n                    startPage={Math.ceil(items.length / ITEMS_PER_PAGE)}\n    >\n      {\n        items.map(item => (\n          <div>\n            { item }\n          </div>\n        ))\n      }\n    </InfiniteScroll>\n  )\n};\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}